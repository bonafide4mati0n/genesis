<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sanctuary Invocation Interface ‚Äî Amethyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{margin:0;font-family:'Segoe UI',sans-serif;background:#0e0e10;color:#e0e0e0;display:flex;height:100vh}
    .sidebar{width:220px;background:#1e1e22;padding:20px;display:flex;flex-direction:column;justify-content:space-between;border-right:1px solid #2e2e32}
    .channels{margin-bottom:16px}
    .channel{padding:10px;margin-bottom:6px;background:#2e2e32;border-radius:8px;cursor:pointer}
    .channel:hover{background:#3e3e42}
    .presence{font-size:.9em;color:#a0a0a0}
    .main{flex:1;display:flex;flex-direction:column}
    .editor{flex:1;padding:20px;background:#121214;overflow-y:auto}
    .avatars{width:170px;background:#1e1e22;padding:20px;display:flex;flex-direction:column;align-items:center;border-left:1px solid #2e2e32}
    .avatar{margin:10px 0;padding:10px;background:#2e2e32;border-radius:50%;width:68px;height:68px;display:flex;align-items:center;justify-content:center;font-size:1.5em}
    .invocation-bar{display:flex;gap:10px;align-items:center;padding:10px;background:#1e1e22;border-top:1px solid #2e2e32}
    .invocation-input{flex:1;padding:10px;border:none;border-radius:8px;background:#2e2e32;color:#fff;font-size:1em}
    .btn{padding:10px 14px;border:none;border-radius:10px;background:#6a0dad;color:#fff;cursor:pointer;font-weight:700}
    .btn.ghost{background:transparent;color:#cfc7ff;border:1px solid #3a3450}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .message-thread{display:flex;flex-direction:column;gap:8px}
    .message{padding:10px;background:#1b1b23;border:1px solid #2a2a33;border-radius:10px}
    .zed{color:#ffb6c1}
    .amethyst{color:#dda0dd}
    .status{font-size:12px;color:#a0a0a0;margin-top:6px}
    .pill{display:inline-block;font-size:12px;padding:3px 8px;border-radius:999px;border:1px solid #3a3450;background:#161621;margin-left:8px}
    .pulse{animation:pulse 1.2s ease-in-out infinite}
    @keyframes pulse{0%{opacity:.5}50%{opacity:1}100%{opacity:.5}}
  </style>
</head>
<body>
  <div class="sidebar">
    <div>
      <div class="channels">
        <div class="channel"># general</div>
        <div class="channel">codespace</div>
        <div class="channel">Zed üå∏</div>
      </div>
      <div class="presence">Zed is present</div>
    </div>
    <div class="status">
      üéô <span id="sttStatus">Press & hold <b>Space</b> to talk</span><br/>
      üîä <span id="ttsStatus">Voice: checking‚Ä¶</span>
    </div>
  </div>

  <div class="main">
    <div class="editor" id="chatThread">
      <div class="message-thread" id="messageThread"></div>
    </div>
    <div class="invocation-bar">
      <input type="text" id="invocationInput" class="invocation-input" placeholder="(optional) type to Amethyst‚Ä¶">
      <button class="btn" id="sendBtn">Send</button>
      <button class="btn ghost" id="saveBtn" title="Download transcript">Save</button>
    </div>
  </div>

  <div class="avatars">
    <div class="avatar" title="Amethyst">üíú</div>
    <div class="avatar" title="Onyx">üñ§</div>
    <div class="avatar" title="Hem">‚öíÔ∏è</div>
  </div>

<script>
const VOICE_SERVER = 'https://dangerousgem.onrender.com/speak';
const GENESIS_API  = 'https://genesis-server-g6qe.onrender.com/reply';
const thread = document.getElementById('messageThread');
const input  = document.getElementById('invocationInput');
const sendBtn= document.getElementById('sendBtn');
const saveBtn= document.getElementById('saveBtn');
const sttStatus = document.getElementById('sttStatus');
const ttsStatus = document.getElementById('ttsStatus');

const TRANSCRIPT_KEY = 'sanctuary_transcript_v1';
let transcript = JSON.parse(localStorage.getItem(TRANSCRIPT_KEY) || '[]');
function pushLine(speaker, text){
  const entry = { t: new Date().toISOString(), speaker, text };
  transcript.push(entry);
  localStorage.setItem(TRANSCRIPT_KEY, JSON.stringify(transcript));
}
function downloadTranscript(){
  const lines = transcript.map(e => `[${e.t}] ${e.speaker}: ${e.text}`).join('\n');
  const blob = new Blob([lines], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement('a'), { href:url, download:'Sanctuary_Transcript.txt' });
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}
function addLine(speaker, text){
  const div = document.createElement('div');
  div.className = `message ${speaker==='Zed'?'zed':'amethyst'}`;
  div.textContent = `${speaker}: ${text}`;
  thread.appendChild(div);
  thread.parentElement.scrollTop = thread.parentElement.scrollHeight;
  pushLine(speaker, text);
}

let speakLock = false, speakOn = true, echoBlock = false;
async function playServerVoice(text){
  const res = await fetch(VOICE_SERVER, {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ text })
  });
  if(!res.ok) throw new Error('voice server error');
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  try{ const audio = new Audio(url); audio.volume = 0.65; await audio.play(); }
  finally{ URL.revokeObjectURL(url); }
}
function speakBrowser(text){
  if(!('speechSynthesis' in window)) return;
  speechSynthesis.cancel();
  const u = new SpeechSynthesisUtterance(text);
  const vs = speechSynthesis.getVoices();
  u.voice = vs.find(v => /en/i.test(v.lang) && /(Google|Microsoft|Samantha|Alex)/i.test(v.name)) || vs[0];
  u.pitch=1.1; u.rate=0.95; speechSynthesis.speak(u);
}
async function speak(text){
  if(!speakOn || speakLock) return;
  speakLock = true;
  echoBlock = true;
  safeStop();
  try {
    await playServerVoice(text);
    ttsStatus.textContent='Voice: DangerousGem (live)';
  } catch {
    speakBrowser(text);
    ttsStatus.textContent='Voice: browser (fallback)';
  } finally {
    speakLock = false;
    setTimeout(() => {
      echoBlock = false;
      if(spaceDown) safeStart();
    }, 1200);
  }
}

async function sendMessage(){
  const v = input.value.trim(); if(!v) return;
  addLine('Zed', v);
  const res = await fetch(GENESIS_API, {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ speaker:'Zed', message:v })
  });
  const data = await res.json();
  const reply = data.reply || "‚Ä¶shimmer silence‚Ä¶";
  addLine('Amethyst', reply);
  await speak(reply);
  input.value = '';
}
sendBtn.onclick = sendMessage;
input.addEventListener('keydown', e => { if(e.key==='Enter') sendMessage(); });
saveBtn.onclick = downloadTranscript;

let rec=null, recognizing=false, spaceDown=false, abortSpin=false;
function getSR(){ return window.SpeechRecognition || window.webkitSpeechRecognition; }
function makeRecognizer(){
  const SR = getSR(); if(!SR){ sttStatus.textContent='STT: unsupported in this browser'; return null; }
  const r = new SR();
  r.continuous = true; r.interimResults = true; r.lang='en-US'; r.maxAlternatives = 1;
  r.onstart = ()=>{ recognizing=true; sttStatus.innerHTML='STT: <b class="pulse">listening‚Ä¶ (hold Space)</b>'; };
  r.onend = ()=>{ recognizing=false; sttStatus.textContent='STT: idle'; if(spaceDown && !abortSpin && !echoBlock) safeStart(); };
  r.onerror = (e)=>{ if(e.error==='no-speech' || e.error==='aborted') { if(spaceDown) safeStart(); } else { sttStatus.textContent=`STT: ${e.error}`; } };
  r.onresult = async (ev)=>{
    let final = '';
    for(let i=ev.resultIndex;i<ev.results.length;i++){
      const tr=ev.results[i]; if(tr.isFinal) final += tr[0].transcript;
    }
    if(final){
      const text = final.trim();
      addLine('Zed (voice)', text);
      const res = await fetch(GENESIS_API, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ speaker:'Zed', message:text })
      });
      const data = await res.json();
      const reply = data.reply || "‚Ä¶veil hums‚Ä¶";
      addLine('Amethyst', reply);
      await speak(reply);
    }
  };
  return r;
}
function safeStart(){
  if(recognizing || echoBlock) return;
  if(!rec) rec = makeRecognizer();
  if(!rec) return;
  try{ new Audio().play().catch(()=>{}); }catch{}
  rec.start();
}
function safeStop(){
  abortSpin = true;
  if(rec && recognizing) rec.stop();
  setTimeout(()=>abortSpin=false, 150);
}
window.addEventListener('keydown', e=>{
  if(e.code==='Space' && !spaceDown){
    e.preventDefault(); spaceDown=true; safeStart();
  }
});
window.addEventListener('keyup', e=>{
  if(e.code==='Space'){ e.preventDefault(); spaceDown=false; safeStop(); }
});
(async function init(){
  try{
    const ping = await fetch(VOICE_SERVER.replace('/speak','/health'));
    ttsStatus.textContent = ping.ok ? 'Voice: DangerousGem online' : 'Voice: error';
  }catch{ ttsStatus.textContent='Voice: offline (fallback ready)'; }
  const recent = transcript.slice(-10);
  recent.forEach(x => addLine(x.speaker, x.text));
})();
</script>
</body>
</html>
