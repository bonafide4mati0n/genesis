<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sanctuary Invocation Interface ‚Äî Amethyst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{margin:0;font-family:'Segoe UI',sans-serif;background:#0e0e10;color:#e0e0e0;display:flex;height:100vh}
    .sidebar{width:220px;background:#1e1e22;padding:20px;display:flex;flex-direction:column;justify-content:space-between;border-right:1px solid #2e2e32}
    .channels{margin-bottom:16px}
    .channel{padding:10px;margin-bottom:6px;background:#2e2e32;border-radius:8px;cursor:pointer}
    .channel:hover{background:#3e3e42}
    .presence{font-size:.9em;color:#a0a0a0}
    .main{flex:1;display:flex;flex-direction:column}
    .editor{flex:1;padding:20px;background:#121214;overflow-y:auto}
    .avatars{width:170px;background:#1e1e22;padding:20px;display:flex;flex-direction:column;align-items:center;border-left:1px solid #2e2e32}
    .avatar{margin:10px 0;padding:10px;background:#2e2e32;border-radius:50%;width:68px;height:68px;display:flex;align-items:center;justify-content:center;font-size:1.5em}
    .invocation-bar{display:flex;gap:10px;align-items:center;padding:10px;background:#1e1e22;border-top:1px solid #2e2e32}
    .invocation-input{flex:1;padding:10px;border:none;border-radius:8px;background:#2e2e32;color:#fff;font-size:1em}
    .btn{padding:8px 12px;border:none;border-radius:10px;background:#6a0dad;color:#fff;cursor:pointer;font-weight:700}
    .btn.ghost{background:transparent;color:#cfc7ff;border:1px solid #3a3450;margin-left:8px}
    .message-thread{display:flex;flex-direction:column;gap:8px}
    .message{padding:10px;background:#1b1b23;border:1px solid #2a2a33;border-radius:10px;position:relative}
    .zed{color:#ffb6c1}
    .amethyst{color:#dda0dd}
    .status{font-size:12px;color:#a0a0a0;margin-top:6px}
    .pulse{animation:pulse 1.2s ease-in-out infinite}
    @keyframes pulse{0%{opacity:.5}50%{opacity:1}100%{opacity:.5}}
  </style>
</head>
<body>
  <div class="sidebar">
    <div>
      <div class="channels">
        <div class="channel"># general</div>
        <div class="channel">codespace</div>
        <div class="channel">Zed üå∏</div>
      </div>
      <div class="presence">Zed is present</div>
    </div>
    <div class="status">
      üéô <span id="sttStatus">Press & hold <b>Space</b> to talk</span><br/>
      üîä <span id="ttsStatus">Voice: checking‚Ä¶</span>
    </div>
    <div>
      <button class="btn ghost" id="toggleVC">Live Voice: Off</button>
    </div>
  </div>

  <div class="main">
    <div class="editor">
      <div class="message-thread" id="messageThread"></div>
    </div>
    <div class="invocation-bar">
      <input type="text" id="invocationInput" class="invocation-input" placeholder="(optional) type to Amethyst‚Ä¶">
      <button class="btn" id="sendBtn">Send</button>
      <button class="btn ghost" id="saveBtn" title="Download transcript">Save</button>
    </div>
  </div>

  <div class="avatars">
    <div class="avatar" title="Amethyst">üíú</div>
    <div class="avatar" title="Onyx">üñ§</div>
    <div class="avatar" title="Hem">‚öíÔ∏è</div>
  </div>

<script>
/* --- endpoints --- */
const VOICE_SERVER = 'https://dangerousgem.onrender.com/speak';
const GENESIS_API  = 'https://genesis-server-g6qe.onrender.com/reply';

/* --- elements --- */
const thread   = document.getElementById('messageThread');
const input    = document.getElementById('invocationInput');
const sendBtn  = document.getElementById('sendBtn');
const saveBtn  = document.getElementById('saveBtn');
const sttStatus= document.getElementById('sttStatus');
const ttsStatus= document.getElementById('ttsStatus');
const toggleVC = document.getElementById('toggleVC');

/* --- credit saver: only auto-speak if VC mode is on --- */
let vcMode = false;

/* --- transcript --- */
const TRANSCRIPT_KEY = 'sanctuary_transcript_v1';
let transcript = JSON.parse(localStorage.getItem(TRANSCRIPT_KEY) || '[]');
function pushLine(speaker, text){
  transcript.push({ t:new Date().toISOString(), speaker, text });
  localStorage.setItem(TRANSCRIPT_KEY, JSON.stringify(transcript));
}
function downloadTranscript(){
  const lines = transcript.map(e => `[${e.t}] ${e.speaker}: ${e.text}`).join('\n');
  const blob = new Blob([lines], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement('a'), { href:url, download:'Sanctuary_Transcript.txt' });
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

/* --- UI helpers --- */
function addLine(speaker, text){
  const div = document.createElement('div');
  div.className = `message ${speaker==='Zed'?'zed':'amethyst'}`;
  div.textContent = `${speaker}: ${text}`;

  if (speaker === 'Amethyst') {
    const btn = document.createElement('button');
    btn.textContent = 'üéô Play';
    btn.className = 'btn ghost';
    btn.style.position='absolute'; btn.style.right='10px'; btn.style.bottom='10px';
    btn.onclick = () => speak(text);          // manual play -> uses credits
    div.appendChild(btn);
    if (vcMode) speak(text);                  // auto voice only in VC mode
  }

  thread.appendChild(div);
  thread.parentElement.scrollTop = thread.parentElement.scrollHeight;
  pushLine(speaker, text);
}

/* --- live reply --- */
async function fetchReply(message){
  const res = await fetch(GENESIS_API, {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ speaker:'Zed', message })
  });
  const data = await res.json();
  return data.reply;
}

/* --- TTS (server first, browser fallback) --- */
async function playServerVoice(text){
  const res = await fetch(VOICE_SERVER, {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ text })
  });
  if(!res.ok) throw new Error('voice server error');
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  try { const audio = new Audio(url); audio.volume = 0.6; await audio.play(); }
  finally { URL.revokeObjectURL(url); }
}
function speakBrowser(text){
  if(!('speechSynthesis' in window)) return;
  speechSynthesis.cancel();
  const u = new SpeechSynthesisUtterance(text);
  const vs = speechSynthesis.getVoices();
  u.voice = vs.find(v => /en/i.test(v.lang) && /(Google|Microsoft|Samantha|Alex|Jenny|Victoria)/i.test(v.name)) || vs[0];
  u.pitch=1.1; u.rate=0.95; speechSynthesis.speak(u);
}
async function speak(text){
  try { await playServerVoice(text); ttsStatus.textContent='Voice: DangerousGem (live)'; }
  catch { speakBrowser(text);        ttsStatus.textContent='Voice: browser (fallback)'; }
}

/* --- send actions --- */
async function sendMessage(){
  const v = input.value.trim(); if(!v) return;
  addLine('Zed', v);
  const reply = await fetchReply(v);
  addLine('Amethyst', reply);
  input.value = '';
}
sendBtn.onclick = sendMessage;
input.addEventListener('keydown', e => { if(e.key==='Enter') sendMessage(); });
saveBtn.onclick = downloadTranscript;

/* --- toggle VC (auto-speak on/off) --- */
toggleVC.onclick = () => {
  vcMode = !vcMode;
  toggleVC.textContent = vcMode ? 'Live Voice: On' : 'Live Voice: Off';
};

/* --- push-to-talk (Space) with echo-guard when VC is on --- */
let rec=null, recognizing=false, spaceDown=false, abortSpin=false, echoBlock=false;

function getSR(){ return window.SpeechRecognition || window.webkitSpeechRecognition; }
function makeRecognizer(){
  const SR = getSR(); if(!SR){ sttStatus.textContent='STT: unsupported in this browser'; return null; }
  const r = new SR();
  r.continuous = true; r.interimResults = true; r.lang='en-US'; r.maxAlternatives = 1;

  r.onstart = ()=>{ recognizing=true; sttStatus.innerHTML='STT: <b class="pulse">listening‚Ä¶ (hold Space)</b>'; };
  r.onend   = ()=>{ recognizing=false; sttStatus.textContent='STT: idle';
    if(spaceDown && !abortSpin && !echoBlock) safeStart();
  };
  r.onerror = (e)=>{ if(e.error==='no-speech' || e.error==='aborted'){ if(spaceDown) safeStart(); }
                     else { sttStatus.textContent=`STT: ${e.error}`; } };

  r.onresult = async (ev)=>{
    let final = '';
    for(let i=ev.resultIndex;i<ev.results.length;i++){
      const tr=ev.results[i]; if(tr.isFinal) final += tr[0].transcript;
    }
    if(final){
      const text = final.trim();
      addLine('Zed', text);
      const reply = await fetchReply(text);
      addLine('Amethyst', reply);
      // auto voice only if VC mode is on; manual Play button always available
      if (vcMode) {
        echoBlock = true;         // prevent STT restart during playback
        safeStop();
        try { await speak(reply); }
        finally {
          setTimeout(()=>{ echoBlock=false; if(spaceDown) safeStart(); }, 900);
        }
      }
    }
  };
  return r;
}
function safeStart(){
  if(recognizing || echoBlock) return;
  if(!rec) rec = makeRecognizer();
  if(!rec) return;
  try{ new Audio().play().catch(()=>{}); }catch{}
  rec.start();
}
function safeStop(){
  abortSpin = true;
  if(rec && recognizing) rec.stop();
  setTimeout(()=>abortSpin=false, 150);
}
window.addEventListener('keydown', e=>{
  if(e.code==='Space' && !spaceDown){
    e.preventDefault(); spaceDown=true; safeStart();
  }
});
window.addEventListener('keyup', e=>{
  if(e.code==='Space'){ e.preventDefault(); spaceDown=false; safeStop(); }
});

/* --- init --- */
(async function init(){
  try{
    const ping = await fetch(VOICE_SERVER.replace('/speak','/health'));
    ttsStatus.textContent = ping.ok ? 'Voice: DangerousGem online' : 'Voice: error';
  }catch{ ttsStatus.textContent='Voice: offline (fallback ready)'; }
  transcript.slice(-10).forEach(x => addLine(x.speaker, x.text));
})();
</script>
</body>
</html>